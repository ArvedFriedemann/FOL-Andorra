Every proper proof system needs a way to do inductions. Often, induction is added as an axiom, but it doesn't have to be. Let's look at an example:

Assume we have a data type, like the natural numbers, defined via a finite conjunction:
forall X . Nat X <-> X = zero v (Exists Y . X = suc Y ^ Nat Y)
Due to the recursive nature of the condition, during deduction, this would result in the infinite disjunction Nat X <-> (X = zer) v (X = suc zero) v (X = suc (suc zero)) v ... . In order to do induction for the property Nat X -> P X with only a finite number of cases, we only want to search for a proof to the two base cases, so X = zero -> P X and (Exists Y . X = suc Y ^ Nat Y) -> P X. At some point, we get back to proving Exists Y . Nat Y -> P X (with some premises), which is quite similar to the original proposition. In classical induction, we'd use the fact that we will prove the condition forall X . Nat X -> P X anyway, so it is applied to make the proof. This however only works if it is known that this proof will eventually be made, a.k.a. that the inference always eventually halts for every concrete natural number. Type checkers therefore use a termination checker, usually based on primitive recursion, to ensure the proof will eventually be deduced. The idea here is just to generalise this concept, such that the termination checker is just added as an axiom and can technically be enhanced.
To formulate it as an axiom, we could first state the premise that the natural number is finite. This could be stated as Finite X <-> X = zero v Exists Y . X = suc Y ^ Finite Y. As this is a premise, the recursive nature of the predicate does not need to be unrolled for the proof. From this we could state Finite X -> ... and could use the finiteness of the data to prove the existence of a proof for our original theorem.

This deduction can work the other way around. If we want to assume a theorem, we can deduce which axioms are needed in order to prove it. This can enhance the "termination checker" automatically.
