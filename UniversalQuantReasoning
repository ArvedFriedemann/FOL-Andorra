Reasoning with Universal Quantifiers

The main purpose of an FOL proof system is to deduce new universal statements. Here, we get over the rules of how this is done.

Working with universal statements:
When having a statement "forall X in E", all E' with X substituted for any variable can be deduced. Therefore, the statement can only hold iff that is possible in the current context without conflict.

Deriving new universal statements:
There is no rule that introduces a universal statement. New universal statements can be created by composition of universal statements, very much like unit propagation. E.g. from "(forall X . A(X)), (forall Y . A(Y) -> B(Y))" follows "forall Z . B(Z)". This behaves very much like a lambda term. Reasoning within the forall binder behaves similar to exist, only that the term cannot be moved out of the binder (it can only be used to create concrete terms).

The main problem of universal quantification is that always exponentially many terms (by depth of the quantification) could be directly deduced in one deduction step. This is, in general, too many. The terms can be created somewhat lazily. So, for all variables in scope, only the first layer of universal quantification is unwrapped. As quantifiers often contain implications, those terms whoms implication premise fails will not be further substituted of pursued. This at least rules out most of the unneccessary terms. So, e.g. if we have "A, B, forall X Y. X = A -> C(Y)", then the first step would look like "A, B, (forall Y . A = A -> C(Y)), (forall Y . B = A -> C(Y)), (forall X Y. X = A -> C(Y))". Evaluatable statements are evaluated, giving "A, B, TOP, forall Y . C (Y), (forall X Y. X = A -> C(Y))". As the "forall Y . B = A -> C(Y)" always holds, it does not need to be checked further, therefore not producing any more clauses.

NOTE: when having a statement "A(t), forall X . A(X), B(X)", where t is a bound variable, then the forall is automatically substituted, so "A(t), B(t), forall X. A(X), B(X)" holds. This is admittedly rather boring as it would have been deduced anyway when doing all substitutions. It becomes more relevant when transforming the posterior of an implication.

In the general scheme, when we just do unit propagation, it is not the goal to preliminarily do deductions anywhere but the highest level. However, sometimes information from the deeper levels are needed to make that decision. This corresponds to transforming lower terms. The decision for when to go deeper has to be deduced somehow.

General idea of constraining unit propagation (with unit propagation):
The problem is that unit propagation can create a lot of terms, especially in the presence of universal statements. Of course, when one is only interested in a certain value, this is a bit of overkill, as lots of unnecessary information it created. Therefore, the whole term could be wrapped in some monad that gives each variable the information whether it is needed or not. Variables that have been deduced stay (who knows what they're good for), but only those atoms are propagated thats propagation leads to a variable needed (or better, they are all propagated, but only those who deduced a needed variable are propagated further). Of course, this might result in a state where no atoms are further propagated, because they did not immediately deduce something useful. Now, those atoms for which a proof exists that they are useful are propagated. If no such proofs exists a search is done...something like that. But the more is known which atoms actually lead to needed variables the fewer things are being evaluated. In andorra style, this would be expressed by a disjunction over all subsets of atoms, choosing subset that is only made of useful atoms. Sounds like overkill...let's think about whether it has to be.

With the big guns: All atoms could be assigned variables of whether they need to be evaluated at the "current" step. Those that are are evaluated. Now, there could be statements that trigger which statements to evaluate next. This way, the propagation would be a bit more constrained. And the same principles hold: It still works on andorra, and if it cannot be deduced what to evaluate, choose. Could this be made directly deterministic? it's kinda getting more and more deterministic...
